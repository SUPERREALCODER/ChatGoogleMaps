{"version":3,"sources":["../../src/utils/index.ts","../../src/utils/utils.ts","../../src/utils/parse-chat-completion.ts","../../src/utils/decode-chat-completion.ts","../../src/utils/decode-chat-completion-as-text.ts","../../src/utils/annotated-function.ts"],"sourcesContent":["export * from \"./utils\";\nexport * from \"./parse-chat-completion\";\nexport * from \"./decode-chat-completion\";\nexport * from \"./decode-chat-completion-as-text\";\nexport * from \"./annotated-function\";\n","import { AssistantMessage, FunctionCall, JSONValue } from \"../types/openai-assistant\";\n\nexport function encodeResult(result: string): string {\n  if (result === undefined) {\n    return \"\";\n  } else if (typeof result === \"string\") {\n    return result;\n  } else {\n    return JSON.stringify(result);\n  }\n}\n\nexport function decodeResult(result: string): any {\n  try {\n    return JSON.parse(result);\n  } catch (e) {\n    return result;\n  }\n}\n\nexport interface StreamPart<CODE extends string, NAME extends string, TYPE> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: StreamPart<\"0\", \"text\", string> = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value: JSONValue) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  },\n};\n\n/**\n * This is a utility function that helps in parsing the stream parts.\n * It takes a JSONValue as input and returns an object with type and value.\n * The type is a string that represents the type of the stream part.\n * The value is the actual value of the stream part.\n * If the input value is not a string, it throws an error.\n */\nconst functionCallStreamPart: StreamPart<\"1\", \"function_call\", { function_call: FunctionCall }> = {\n  code: \"1\",\n  name: \"function_call\",\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== \"object\" ||\n      !(\"function_call\" in value) ||\n      typeof value.function_call !== \"object\" ||\n      value.function_call == null ||\n      !(\"name\" in value.function_call) ||\n      !(\"arguments\" in value.function_call) ||\n      typeof value.function_call.name !== \"string\" ||\n      typeof value.function_call.arguments !== \"string\"\n    ) {\n      throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n    }\n\n    return {\n      type: \"function_call\",\n      value: value as unknown as { function_call: FunctionCall },\n    };\n  },\n};\n\nconst dataStreamPart: StreamPart<\"2\", \"data\", Array<JSONValue>> = {\n  code: \"2\",\n  name: \"data\",\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n\n    return { type: \"data\", value };\n  },\n};\n\nconst errorStreamPart: StreamPart<\"3\", \"error\", string> = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value: JSONValue) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  },\n};\n\nconst assistantMessage: StreamPart<\"4\", \"assistant_message\", AssistantMessage> = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== \"object\" ||\n      !(\"id\" in value) ||\n      !(\"role\" in value) ||\n      !(\"content\" in value) ||\n      typeof value.id !== \"string\" ||\n      typeof value.role !== \"string\" ||\n      value.role !== \"assistant\" ||\n      !Array.isArray(value.content) ||\n      !value.content.every(\n        (item) =>\n          item != null &&\n          typeof item === \"object\" &&\n          \"type\" in item &&\n          item.type === \"text\" &&\n          \"text\" in item &&\n          item.text != null &&\n          typeof item.text === \"object\" &&\n          \"value\" in item.text &&\n          typeof item.text.value === \"string\",\n      )\n    ) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.',\n      );\n    }\n\n    return {\n      type: \"assistant_message\",\n      value: value as AssistantMessage,\n    };\n  },\n};\n\nconst assistantControlData: StreamPart<\n  \"5\",\n  \"assistant_control_data\",\n  {\n    threadId: string;\n    messageId: string;\n  }\n> = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== \"object\" ||\n      !(\"threadId\" in value) ||\n      !(\"messageId\" in value) ||\n      typeof value.threadId !== \"string\" ||\n      typeof value.messageId !== \"string\"\n    ) {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.',\n      );\n    }\n\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst streamParts = [\n  textStreamPart,\n  functionCallStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  assistantMessage,\n  assistantControlData,\n] as const;\n\n// union type of all stream parts\ntype StreamParts =\n  | typeof textStreamPart\n  | typeof functionCallStreamPart\n  | typeof dataStreamPart\n  | typeof errorStreamPart\n  | typeof assistantMessage\n  | typeof assistantControlData;\n\n/**\n * Maps the type of a stream part to its value type.\n */\ntype StreamPartValueType = {\n  [P in StreamParts as P[\"name\"]]: ReturnType<P[\"parse\"]>[\"value\"];\n};\n\nexport type StreamPartType =\n  | ReturnType<typeof textStreamPart.parse>\n  | ReturnType<typeof functionCallStreamPart.parse>\n  | ReturnType<typeof dataStreamPart.parse>\n  | ReturnType<typeof errorStreamPart.parse>\n  | ReturnType<typeof assistantMessage.parse>\n  | ReturnType<typeof assistantControlData.parse>;\n\nexport const streamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [functionCallStreamPart.code]: functionCallStreamPart,\n  [dataStreamPart.code]: dataStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessage.code]: assistantMessage,\n  [assistantControlData.code]: assistantControlData,\n} as const;\n\n/**\n * The map of prefixes for data in the stream\n *\n * - 0: Text from the LLM response\n * - 1: (OpenAI) function_call responses\n * - 2: custom JSON added by the user using `Data`\n *\n * Example:\n * ```\n * 0:Vercel\n * 0:'s\n * 0: AI\n * 0: AI\n * 0: SDK\n * 0: is great\n * 0:!\n * 2: { \"someJson\": \"value\" }\n * 1: {\"function_call\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}\n *```\n */\nexport const StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [functionCallStreamPart.name]: functionCallStreamPart.code,\n  [dataStreamPart.name]: dataStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessage.name]: assistantMessage.code,\n  [assistantControlData.name]: assistantControlData.code,\n} as const;\n\nexport const validCodes = streamParts.map((part) => part.code);\n\n/**\n * Parses a stream part from a string.\n *\n * @param line The string to parse.\n * @returns The parsed stream part.\n * @throws An error if the string cannot be parsed.\n */\nexport const parseStreamPart = (line: string): StreamPartType => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof streamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof streamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return streamPartsByCode[code].parse(jsonValue);\n};\n\n/**\n * Prepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it,\n * and appends a new line.\n *\n * It ensures type-safety for the part type and value.\n */\nexport function formatStreamPart<T extends keyof StreamPartValueType>(\n  type: T,\n  value: StreamPartValueType[T],\n): StreamString {\n  const streamPart = streamParts.find((part) => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n\nexport const isStreamStringEqualToType = (\n  type: keyof typeof StreamStringPrefixes,\n  value: string,\n): value is StreamString =>\n  value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith(\"\\n\");\n\nexport type StreamString =\n  `${(typeof StreamStringPrefixes)[keyof typeof StreamStringPrefixes]}:${string}\\n`;\n\n/**\n * A header sent to the client so it knows how to handle parsing the stream (as a deprecated text response or using the new prefixed protocol)\n */\nexport const COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n","import { Role } from \"../types/openai-assistant\";\n\nexport interface ToolCallFunctionCall {\n  arguments?: string;\n\n  name?: string;\n  // TODO:\n  // Temporarily add scope to the OpenAI protocol until we\n  // have our own protocol.\n  // When scope is \"server\", the client will not attempt to\n  // execute the function.\n  scope?: \"client\" | \"server\";\n}\n\nexport interface ToolCallPayload {\n  index: number;\n  id?: string;\n  function: ToolCallFunctionCall;\n}\n\nexport interface ChatCompletionChunk {\n  choices: {\n    delta: {\n      id?: string;\n      role: Role;\n      content?: string | null;\n\n      // TODO:\n      // Temporarily add name to the OpenAI protocol until we\n      // have our own protocol.\n      // When name is set, we return the result of a server-side\n      // function call.\n      name?: string;\n\n      function_call?: {\n        name?: string;\n        arguments?: string;\n      };\n      tool_calls?: ToolCallPayload[];\n    };\n  }[];\n}\n\n// TODO:\n// it's possible that unicode characters could be split across chunks\n// make sure to properly handle that\nexport function parseChatCompletion(\n  stream: ReadableStream<Uint8Array>,\n): ReadableStream<ChatCompletionChunk> {\n  const reader = stream.getReader();\n  let buffer = new Uint8Array();\n\n  async function cleanup(controller?: ReadableStreamDefaultController<any>) {\n    if (controller) {\n      try {\n        controller.close();\n      } catch (_) {}\n    }\n    if (reader) {\n      try {\n        await reader.cancel();\n      } catch (_) {}\n    }\n  }\n\n  return new ReadableStream<ChatCompletionChunk>({\n    async pull(controller) {\n      while (true) {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            await cleanup(controller);\n            return;\n          }\n\n          const newBuffer = new Uint8Array(buffer.length + value.length);\n          newBuffer.set(buffer);\n          newBuffer.set(value, buffer.length);\n          buffer = newBuffer;\n\n          const valueString = new TextDecoder(\"utf-8\").decode(buffer);\n          const lines = valueString.split(\"\\n\").filter((line) => line.trim() !== \"\");\n\n          // If the last line isn't complete, keep it in the buffer for next time\n          buffer = !valueString.endsWith(\"\\n\")\n            ? new TextEncoder().encode(lines.pop() || \"\")\n            : new Uint8Array();\n\n          for (const line of lines) {\n            const cleanedLine = line.replace(/^data: /, \"\");\n\n            if (cleanedLine === \"[DONE]\") {\n              await cleanup(controller);\n              return;\n            }\n\n            const json = JSON.parse(cleanedLine);\n            controller.enqueue(json);\n          }\n        } catch (error) {\n          controller.error(error);\n          await cleanup(controller);\n          return;\n        }\n      }\n    },\n    cancel() {\n      reader.cancel();\n    },\n  });\n}\n","import { ChatCompletionChunk, ToolCallFunctionCall } from \"./parse-chat-completion\";\n\nexport interface ChatCompletionContentEvent {\n  type: \"content\";\n  content: string;\n}\n\nexport interface ChatCompletionPartialEvent {\n  type: \"partial\";\n  name: string;\n  arguments: string;\n}\n\nexport interface ChatCompletionFunctionEvent {\n  type: \"function\";\n  name: string;\n  arguments: any;\n  scope: \"client\" | \"server\";\n}\n\nexport interface ChatCompletionResultEvent {\n  type: \"result\";\n  content: string;\n  name: string;\n}\n\nexport type ChatCompletionEvent =\n  | ChatCompletionContentEvent\n  | ChatCompletionPartialEvent\n  | ChatCompletionFunctionEvent\n  | ChatCompletionResultEvent;\n\nexport function decodeChatCompletion(\n  stream: ReadableStream<ChatCompletionChunk>,\n): ReadableStream<ChatCompletionEvent> {\n  const reader = stream.getReader();\n\n  type Mode = { type: \"function\"; function: ToolCallFunctionCall } | { type: \"message\" };\n\n  let mode: Mode | null = null;\n  let functionCallName: string = \"\";\n  let functionCallArguments: string = \"\";\n  let functionCallScope: \"client\" | \"server\" = \"client\";\n\n  async function cleanup(controller?: ReadableStreamDefaultController<any>) {\n    if (controller) {\n      try {\n        controller.close();\n      } catch (_) {}\n    }\n    if (reader) {\n      try {\n        await reader.cancel();\n      } catch (_) {}\n    }\n  }\n\n  return new ReadableStream<ChatCompletionEvent>({\n    async pull(controller) {\n      const flushFunctionCall = (): boolean => {\n        let args: any = null;\n        try {\n          args = JSON.parse(functionCallArguments);\n        } catch (error) {\n          cleanup(controller);\n          controller.error(error);\n          return false;\n        }\n        controller.enqueue({\n          type: \"function\",\n          name: functionCallName,\n          arguments: args,\n          scope: functionCallScope,\n        });\n\n        mode = null;\n        functionCallName = \"\";\n        functionCallArguments = \"\";\n        return true;\n      };\n\n      while (true) {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            if (mode?.type === \"function\") {\n              flushFunctionCall();\n            }\n            await cleanup(controller);\n            return;\n          }\n\n          // In case we are currently handling a function call but the next message is either\n          // - not a function call\n          // - or is another function call (indicated by the presence of 'name' field in the next function call object)\n          // => flush the current function call.\n          if (\n            mode?.type === \"function\" &&\n            (!value.choices[0].delta.tool_calls?.[0]?.function ||\n              value.choices[0].delta.tool_calls?.[0]?.function.name)\n          ) {\n            if (!flushFunctionCall()) {\n              return;\n            }\n          }\n\n          const maybeFunctionCall = value.choices[0].delta.tool_calls?.[0]?.function;\n          if (maybeFunctionCall) {\n            mode = { type: \"function\", function: maybeFunctionCall };\n          } else {\n            mode = { type: \"message\" };\n          }\n\n          // if we get a message, emit the content and continue;\n          if (mode.type === \"message\") {\n            // if we got a result message, send a result event\n            if (value.choices[0].delta.role === \"function\") {\n              controller.enqueue({\n                type: \"result\",\n                content: value.choices[0].delta.content!,\n                name: value.choices[0].delta.name!,\n              });\n            }\n            // otherwise, send a content event\n            else if (value.choices[0].delta.content) {\n              controller.enqueue({\n                type: \"content\",\n                content: value.choices[0].delta.content,\n              });\n            }\n            continue;\n          }\n          // if we get a function call, buffer the name and arguments, then emit a partial event.\n          else if (mode.type === \"function\") {\n            const maybeFunctionCallName = mode.function.name;\n            if (maybeFunctionCallName) {\n              functionCallName = maybeFunctionCallName;\n            }\n\n            const maybeFunctionCallArguments = mode.function.arguments;\n            if (maybeFunctionCallArguments) {\n              functionCallArguments += maybeFunctionCallArguments;\n            }\n\n            const maybeFunctionCallScope = mode.function.scope;\n            if (maybeFunctionCallScope) {\n              functionCallScope = maybeFunctionCallScope;\n            }\n\n            controller.enqueue({\n              type: \"partial\",\n              name: functionCallName,\n              arguments: functionCallArguments,\n            });\n            continue;\n          }\n        } catch (error) {\n          controller.error(error);\n          await cleanup(controller);\n          return;\n        }\n      }\n    },\n    cancel() {\n      reader.cancel();\n    },\n  });\n}\n","import { ChatCompletionEvent } from \"./decode-chat-completion\";\n\nexport function decodeChatCompletionAsText(\n  stream: ReadableStream<ChatCompletionEvent>,\n): ReadableStream<string> {\n  const reader = stream.getReader();\n\n  return new ReadableStream<string>({\n    async pull(controller) {\n      while (true) {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            controller.close();\n            return;\n          }\n\n          if (value.type === \"content\") {\n            controller.enqueue(value.content);\n            continue;\n          }\n        } catch (error) {\n          controller.error(error);\n          return;\n        }\n      }\n    },\n    cancel() {\n      reader.cancel();\n    },\n  });\n}\n","import { Action, AnnotatedFunction, ToolDefinition, Parameter } from \"../types\";\n\nexport function annotatedFunctionToChatCompletionFunction(\n  annotatedFunction: AnnotatedFunction<any[]>,\n): ToolDefinition {\n  // Create the parameters object based on the argumentAnnotations\n  let parameters: { [key: string]: any } = {};\n  for (let arg of annotatedFunction.argumentAnnotations) {\n    // isolate the args we should forward inline\n    let { name, required, ...forwardedArgs } = arg;\n    parameters[arg.name] = forwardedArgs;\n  }\n\n  let requiredParameterNames: string[] = [];\n  for (let arg of annotatedFunction.argumentAnnotations) {\n    if (arg.required) {\n      requiredParameterNames.push(arg.name);\n    }\n  }\n\n  // Create the ChatCompletionFunctions object\n  let chatCompletionFunction: ToolDefinition = {\n    type: \"function\",\n    function: {\n      name: annotatedFunction.name,\n      description: annotatedFunction.description,\n      parameters: {\n        type: \"object\",\n        properties: parameters,\n        required: requiredParameterNames,\n      },\n    },\n  };\n\n  return chatCompletionFunction;\n}\n\nfunction convertAttribute(attribute: Parameter): any {\n  switch (attribute.type) {\n    case \"string\":\n      return {\n        type: \"string\",\n        description: attribute.description,\n        ...(attribute.enum && { enum: attribute.enum }),\n      };\n    case \"number\":\n    case \"boolean\":\n      return {\n        type: attribute.type,\n        description: attribute.description,\n      };\n    case \"object\":\n    case \"object[]\":\n      const properties = attribute.attributes?.reduce(\n        (acc, attr) => {\n          acc[attr.name] = convertAttribute(attr);\n          return acc;\n        },\n        {} as Record<string, any>,\n      );\n      const required = attribute.attributes\n        ?.filter((attr) => attr.required !== false)\n        .map((attr) => attr.name);\n      if (attribute.type === \"object[]\") {\n        return {\n          type: \"array\",\n          items: {\n            type: \"object\",\n            ...(properties && { properties }),\n            ...(required && required.length > 0 && { required }),\n          },\n          description: attribute.description,\n        };\n      }\n      return {\n        type: \"object\",\n        description: attribute.description,\n        ...(properties && { properties }),\n        ...(required && required.length > 0 && { required }),\n      };\n    default:\n      // Handle arrays of primitive types and undefined attribute.type\n      if (attribute.type?.endsWith(\"[]\")) {\n        const itemType = attribute.type.slice(0, -2);\n        return {\n          type: \"array\",\n          items: { type: itemType },\n          description: attribute.description,\n        };\n      }\n      // Fallback for undefined type or any other unexpected type\n      return {\n        type: \"string\",\n        description: attribute.description,\n      };\n  }\n}\n\nexport function actionToChatCompletionFunction(action: Action<any>): ToolDefinition {\n  // Create the parameters object based on the argumentAnnotations\n  let parameters: { [key: string]: any } = {};\n  for (let parameter of action.parameters || []) {\n    parameters[parameter.name] = convertAttribute(parameter);\n  }\n\n  let requiredParameterNames: string[] = [];\n  for (let arg of action.parameters || []) {\n    if (arg.required !== false) {\n      requiredParameterNames.push(arg.name);\n    }\n  }\n\n  // Create the ChatCompletionFunctions object\n  let chatCompletionFunction: ToolDefinition = {\n    type: \"function\",\n    function: {\n      name: action.name,\n      ...(action.description && { description: action.description }),\n      parameters: {\n        type: \"object\",\n        properties: parameters,\n        required: requiredParameterNames,\n      },\n    },\n  };\n\n  return chatCompletionFunction;\n}\n\nexport function annotatedFunctionToAction(\n  annotatedFunction: AnnotatedFunction<any[]>,\n): Action<any> {\n  const parameters: Parameter[] = annotatedFunction.argumentAnnotations.map((annotation) => {\n    switch (annotation.type) {\n      case \"string\":\n      case \"number\":\n      case \"boolean\":\n      case \"object\":\n        return {\n          name: annotation.name,\n          description: annotation.description,\n          type: annotation.type,\n          required: annotation.required,\n        };\n      case \"array\":\n        let type;\n        if (annotation.items.type === \"string\") {\n          type = \"string[]\";\n        } else if (annotation.items.type === \"number\") {\n          type = \"number[]\";\n        } else if (annotation.items.type === \"boolean\") {\n          type = \"boolean[]\";\n        } else if (annotation.items.type === \"object\") {\n          type = \"object[]\";\n        } else {\n          type = \"string[]\";\n        }\n        return {\n          name: annotation.name,\n          description: annotation.description,\n          type: type as any,\n          required: annotation.required,\n        };\n    }\n  });\n\n  return {\n    name: annotatedFunction.name,\n    description: annotatedFunction.description,\n    parameters: parameters,\n    handler: (args) => {\n      const paramsInCorrectOrder: any[] = [];\n      for (let arg of annotatedFunction.argumentAnnotations) {\n        paramsInCorrectOrder.push(args[arg.name]);\n      }\n      return annotatedFunction.implementation(...paramsInCorrectOrder);\n    },\n  };\n}\n"],"mappings":"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","names":[]}