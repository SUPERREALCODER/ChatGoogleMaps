{"version":3,"sources":["../../src/utils/decode-chat-completion.ts"],"sourcesContent":["import { ChatCompletionChunk, ToolCallFunctionCall } from \"./parse-chat-completion\";\n\nexport interface ChatCompletionContentEvent {\n  type: \"content\";\n  content: string;\n}\n\nexport interface ChatCompletionPartialEvent {\n  type: \"partial\";\n  name: string;\n  arguments: string;\n}\n\nexport interface ChatCompletionFunctionEvent {\n  type: \"function\";\n  name: string;\n  arguments: any;\n  scope: \"client\" | \"server\";\n}\n\nexport interface ChatCompletionResultEvent {\n  type: \"result\";\n  content: string;\n  name: string;\n}\n\nexport type ChatCompletionEvent =\n  | ChatCompletionContentEvent\n  | ChatCompletionPartialEvent\n  | ChatCompletionFunctionEvent\n  | ChatCompletionResultEvent;\n\nexport function decodeChatCompletion(\n  stream: ReadableStream<ChatCompletionChunk>,\n): ReadableStream<ChatCompletionEvent> {\n  const reader = stream.getReader();\n\n  type Mode = { type: \"function\"; function: ToolCallFunctionCall } | { type: \"message\" };\n\n  let mode: Mode | null = null;\n  let functionCallName: string = \"\";\n  let functionCallArguments: string = \"\";\n  let functionCallScope: \"client\" | \"server\" = \"client\";\n\n  async function cleanup(controller?: ReadableStreamDefaultController<any>) {\n    if (controller) {\n      try {\n        controller.close();\n      } catch (_) {}\n    }\n    if (reader) {\n      try {\n        await reader.cancel();\n      } catch (_) {}\n    }\n  }\n\n  return new ReadableStream<ChatCompletionEvent>({\n    async pull(controller) {\n      const flushFunctionCall = (): boolean => {\n        let args: any = null;\n        try {\n          args = JSON.parse(functionCallArguments);\n        } catch (error) {\n          cleanup(controller);\n          controller.error(error);\n          return false;\n        }\n        controller.enqueue({\n          type: \"function\",\n          name: functionCallName,\n          arguments: args,\n          scope: functionCallScope,\n        });\n\n        mode = null;\n        functionCallName = \"\";\n        functionCallArguments = \"\";\n        return true;\n      };\n\n      while (true) {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            if (mode?.type === \"function\") {\n              flushFunctionCall();\n            }\n            await cleanup(controller);\n            return;\n          }\n\n          // In case we are currently handling a function call but the next message is either\n          // - not a function call\n          // - or is another function call (indicated by the presence of 'name' field in the next function call object)\n          // => flush the current function call.\n          if (\n            mode?.type === \"function\" &&\n            (!value.choices[0].delta.tool_calls?.[0]?.function ||\n              value.choices[0].delta.tool_calls?.[0]?.function.name)\n          ) {\n            if (!flushFunctionCall()) {\n              return;\n            }\n          }\n\n          const maybeFunctionCall = value.choices[0].delta.tool_calls?.[0]?.function;\n          if (maybeFunctionCall) {\n            mode = { type: \"function\", function: maybeFunctionCall };\n          } else {\n            mode = { type: \"message\" };\n          }\n\n          // if we get a message, emit the content and continue;\n          if (mode.type === \"message\") {\n            // if we got a result message, send a result event\n            if (value.choices[0].delta.role === \"function\") {\n              controller.enqueue({\n                type: \"result\",\n                content: value.choices[0].delta.content!,\n                name: value.choices[0].delta.name!,\n              });\n            }\n            // otherwise, send a content event\n            else if (value.choices[0].delta.content) {\n              controller.enqueue({\n                type: \"content\",\n                content: value.choices[0].delta.content,\n              });\n            }\n            continue;\n          }\n          // if we get a function call, buffer the name and arguments, then emit a partial event.\n          else if (mode.type === \"function\") {\n            const maybeFunctionCallName = mode.function.name;\n            if (maybeFunctionCallName) {\n              functionCallName = maybeFunctionCallName;\n            }\n\n            const maybeFunctionCallArguments = mode.function.arguments;\n            if (maybeFunctionCallArguments) {\n              functionCallArguments += maybeFunctionCallArguments;\n            }\n\n            const maybeFunctionCallScope = mode.function.scope;\n            if (maybeFunctionCallScope) {\n              functionCallScope = maybeFunctionCallScope;\n            }\n\n            controller.enqueue({\n              type: \"partial\",\n              name: functionCallName,\n              arguments: functionCallArguments,\n            });\n            continue;\n          }\n        } catch (error) {\n          controller.error(error);\n          await cleanup(controller);\n          return;\n        }\n      }\n    },\n    cancel() {\n      reader.cancel();\n    },\n  });\n}\n"],"mappings":"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","names":[]}