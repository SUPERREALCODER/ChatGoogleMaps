{"version":3,"sources":["../src/utils/annotated-function.ts"],"sourcesContent":["import { Action, AnnotatedFunction, ToolDefinition, Parameter } from \"../types\";\n\nexport function annotatedFunctionToChatCompletionFunction(\n  annotatedFunction: AnnotatedFunction<any[]>,\n): ToolDefinition {\n  // Create the parameters object based on the argumentAnnotations\n  let parameters: { [key: string]: any } = {};\n  for (let arg of annotatedFunction.argumentAnnotations) {\n    // isolate the args we should forward inline\n    let { name, required, ...forwardedArgs } = arg;\n    parameters[arg.name] = forwardedArgs;\n  }\n\n  let requiredParameterNames: string[] = [];\n  for (let arg of annotatedFunction.argumentAnnotations) {\n    if (arg.required) {\n      requiredParameterNames.push(arg.name);\n    }\n  }\n\n  // Create the ChatCompletionFunctions object\n  let chatCompletionFunction: ToolDefinition = {\n    type: \"function\",\n    function: {\n      name: annotatedFunction.name,\n      description: annotatedFunction.description,\n      parameters: {\n        type: \"object\",\n        properties: parameters,\n        required: requiredParameterNames,\n      },\n    },\n  };\n\n  return chatCompletionFunction;\n}\n\nfunction convertAttribute(attribute: Parameter): any {\n  switch (attribute.type) {\n    case \"string\":\n      return {\n        type: \"string\",\n        description: attribute.description,\n        ...(attribute.enum && { enum: attribute.enum }),\n      };\n    case \"number\":\n    case \"boolean\":\n      return {\n        type: attribute.type,\n        description: attribute.description,\n      };\n    case \"object\":\n    case \"object[]\":\n      const properties = attribute.attributes?.reduce(\n        (acc, attr) => {\n          acc[attr.name] = convertAttribute(attr);\n          return acc;\n        },\n        {} as Record<string, any>,\n      );\n      const required = attribute.attributes\n        ?.filter((attr) => attr.required !== false)\n        .map((attr) => attr.name);\n      if (attribute.type === \"object[]\") {\n        return {\n          type: \"array\",\n          items: {\n            type: \"object\",\n            ...(properties && { properties }),\n            ...(required && required.length > 0 && { required }),\n          },\n          description: attribute.description,\n        };\n      }\n      return {\n        type: \"object\",\n        description: attribute.description,\n        ...(properties && { properties }),\n        ...(required && required.length > 0 && { required }),\n      };\n    default:\n      // Handle arrays of primitive types and undefined attribute.type\n      if (attribute.type?.endsWith(\"[]\")) {\n        const itemType = attribute.type.slice(0, -2);\n        return {\n          type: \"array\",\n          items: { type: itemType },\n          description: attribute.description,\n        };\n      }\n      // Fallback for undefined type or any other unexpected type\n      return {\n        type: \"string\",\n        description: attribute.description,\n      };\n  }\n}\n\nexport function actionToChatCompletionFunction(action: Action<any>): ToolDefinition {\n  // Create the parameters object based on the argumentAnnotations\n  let parameters: { [key: string]: any } = {};\n  for (let parameter of action.parameters || []) {\n    parameters[parameter.name] = convertAttribute(parameter);\n  }\n\n  let requiredParameterNames: string[] = [];\n  for (let arg of action.parameters || []) {\n    if (arg.required !== false) {\n      requiredParameterNames.push(arg.name);\n    }\n  }\n\n  // Create the ChatCompletionFunctions object\n  let chatCompletionFunction: ToolDefinition = {\n    type: \"function\",\n    function: {\n      name: action.name,\n      ...(action.description && { description: action.description }),\n      parameters: {\n        type: \"object\",\n        properties: parameters,\n        required: requiredParameterNames,\n      },\n    },\n  };\n\n  return chatCompletionFunction;\n}\n\nexport function annotatedFunctionToAction(\n  annotatedFunction: AnnotatedFunction<any[]>,\n): Action<any> {\n  const parameters: Parameter[] = annotatedFunction.argumentAnnotations.map((annotation) => {\n    switch (annotation.type) {\n      case \"string\":\n      case \"number\":\n      case \"boolean\":\n      case \"object\":\n        return {\n          name: annotation.name,\n          description: annotation.description,\n          type: annotation.type,\n          required: annotation.required,\n        };\n      case \"array\":\n        let type;\n        if (annotation.items.type === \"string\") {\n          type = \"string[]\";\n        } else if (annotation.items.type === \"number\") {\n          type = \"number[]\";\n        } else if (annotation.items.type === \"boolean\") {\n          type = \"boolean[]\";\n        } else if (annotation.items.type === \"object\") {\n          type = \"object[]\";\n        } else {\n          type = \"string[]\";\n        }\n        return {\n          name: annotation.name,\n          description: annotation.description,\n          type: type as any,\n          required: annotation.required,\n        };\n    }\n  });\n\n  return {\n    name: annotatedFunction.name,\n    description: annotatedFunction.description,\n    parameters: parameters,\n    handler: (args) => {\n      const paramsInCorrectOrder: any[] = [];\n      for (let arg of annotatedFunction.argumentAnnotations) {\n        paramsInCorrectOrder.push(args[arg.name]);\n      }\n      return annotatedFunction.implementation(...paramsInCorrectOrder);\n    },\n  };\n}\n"],"mappings":"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","names":[]}