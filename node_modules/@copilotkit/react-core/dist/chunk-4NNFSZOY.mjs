import {
  fetchAndDecodeChatCompletion
} from "./chunk-CGT3AVYT.mjs";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-MRXNTQOX.mjs";

// src/hooks/use-chat.ts
import { useRef, useState } from "react";
import {
  encodeResult,
  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER
} from "@copilotkit/shared";
import { nanoid } from "nanoid";
import untruncateJson from "untruncate-json";
function useChat(options) {
  const { messages, setMessages } = options;
  const [input, setInput] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const abortControllerRef = useRef();
  const threadIdRef = useRef(null);
  const runIdRef = useRef(null);
  const publicApiKey = options.copilotConfig.publicApiKey;
  const headers = __spreadValues(__spreadValues({}, options.headers || {}), publicApiKey ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey } : {});
  const runChatCompletion = (messages2) => __async(this, null, function* () {
    setIsLoading(true);
    const newMessages = [
      {
        id: nanoid(),
        createdAt: /* @__PURE__ */ new Date(),
        content: "",
        role: "assistant"
      }
    ];
    const abortController = new AbortController();
    abortControllerRef.current = abortController;
    setMessages([...messages2, ...newMessages]);
    const copilotConfigBody = options.copilotConfig.body || {};
    if (threadIdRef.current) {
      copilotConfigBody.threadId = threadIdRef.current;
    }
    if (runIdRef.current) {
      copilotConfigBody.runId = runIdRef.current;
    }
    const messagesWithContext = [...options.initialMessages || [], ...messages2];
    const response = yield fetchAndDecodeChatCompletion({
      copilotConfig: __spreadProps(__spreadValues({}, options.copilotConfig), { body: copilotConfigBody }),
      messages: messagesWithContext,
      tools: options.tools,
      headers,
      signal: abortController.signal
    });
    if (response.headers.get("threadid")) {
      threadIdRef.current = response.headers.get("threadid");
    }
    if (response.headers.get("runid")) {
      runIdRef.current = response.headers.get("runid");
    }
    if (!response.events) {
      setMessages([
        ...messages2,
        {
          id: nanoid(),
          createdAt: /* @__PURE__ */ new Date(),
          content: response.statusText,
          role: "assistant"
        }
      ]);
      setIsLoading(false);
      throw new Error("Failed to fetch chat completion");
    }
    const reader = response.events.getReader();
    let feedback = false;
    try {
      while (true) {
        const { done, value } = yield reader.read();
        if (done) {
          break;
        }
        let currentMessage = Object.assign({}, newMessages[newMessages.length - 1]);
        if (value.type === "content") {
          if (currentMessage.function_call || currentMessage.role === "function") {
            currentMessage = {
              id: nanoid(),
              createdAt: /* @__PURE__ */ new Date(),
              content: "",
              role: "assistant"
            };
            newMessages.push(currentMessage);
          }
          currentMessage.content += value.content;
          newMessages[newMessages.length - 1] = currentMessage;
          setMessages([...messages2, ...newMessages]);
        } else if (value.type === "result") {
          currentMessage = {
            id: nanoid(),
            role: "function",
            content: value.content,
            name: value.name
          };
          newMessages.push(currentMessage);
          setMessages([...messages2, ...newMessages]);
          feedback = true;
        } else if (value.type === "function" || value.type === "partial") {
          if (currentMessage.content != "" || currentMessage.function_call || currentMessage.role == "function") {
            currentMessage = {
              id: nanoid(),
              createdAt: /* @__PURE__ */ new Date(),
              content: "",
              role: "assistant"
            };
            newMessages.push(currentMessage);
          }
          if (value.type === "function") {
            currentMessage.function_call = {
              name: value.name,
              arguments: JSON.stringify(value.arguments),
              scope: value.scope
            };
          } else if (value.type === "partial") {
            let partialArguments = {};
            try {
              partialArguments = JSON.parse(untruncateJson(value.arguments));
            } catch (e) {
            }
            currentMessage.partialFunctionCall = {
              name: value.name,
              arguments: partialArguments
            };
          }
          newMessages[newMessages.length - 1] = currentMessage;
          setMessages([...messages2, ...newMessages]);
          if (value.type === "function") {
            try {
              if (options.onFunctionCall && value.scope === "client") {
                const result = yield options.onFunctionCall(
                  messages2,
                  currentMessage.function_call
                );
                currentMessage = {
                  id: nanoid(),
                  role: "function",
                  content: encodeResult(result),
                  name: currentMessage.function_call.name
                };
                newMessages.push(currentMessage);
                setMessages([...messages2, ...newMessages]);
                feedback = true;
              }
            } catch (error) {
              console.error("Failed to execute function call", error);
            }
          }
        }
      }
      if (feedback) {
        return yield runChatCompletion([...messages2, ...newMessages]);
      } else {
        return newMessages.slice();
      }
    } finally {
      setIsLoading(false);
    }
  });
  const runChatCompletionAndHandleFunctionCall = (messages2) => __async(this, null, function* () {
    yield runChatCompletion(messages2);
  });
  const append = (message) => __async(this, null, function* () {
    if (isLoading) {
      return;
    }
    const newMessages = [...messages, message];
    setMessages(newMessages);
    return runChatCompletionAndHandleFunctionCall(newMessages);
  });
  const reload = () => __async(this, null, function* () {
    if (isLoading || messages.length === 0) {
      return;
    }
    let newMessages = [...messages];
    const lastMessage = messages[messages.length - 1];
    if (lastMessage.role === "assistant") {
      newMessages = newMessages.slice(0, -1);
    }
    setMessages(newMessages);
    return runChatCompletionAndHandleFunctionCall(newMessages);
  });
  const stop = () => {
    var _a;
    (_a = abortControllerRef.current) == null ? void 0 : _a.abort();
  };
  return {
    append,
    reload,
    stop,
    isLoading,
    input,
    setInput
  };
}

export {
  useChat
};
//# sourceMappingURL=chunk-4NNFSZOY.mjs.map