import {
  use_flat_category_store_default
} from "./chunk-YULKJPY3.mjs";
import {
  use_tree_default
} from "./chunk-VUY2K2DI.mjs";
import {
  CopilotContext
} from "./chunk-O35YOIHC.mjs";
import {
  __async,
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-MRXNTQOX.mjs";

// src/components/copilot-provider/copilotkit.tsx
import { useCallback, useRef, useState } from "react";
import {
  COPILOT_CLOUD_CHAT_URL,
  actionToChatCompletionFunction
} from "@copilotkit/shared";
import { jsx } from "react/jsx-runtime";
function CopilotKit(_a) {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  var _a2, _b2;
  if (!props.runtimeUrl && !props.url && !props.publicApiKey) {
    throw new Error("Please provide either a url or a publicApiKey to the CopilotKit component.");
  }
  const chatApiEndpoint = props.runtimeUrl || props.url || COPILOT_CLOUD_CHAT_URL;
  const [entryPoints, setEntryPoints] = useState({});
  const chatComponentsCache = useRef({});
  const { addElement, removeElement, printTree } = use_tree_default();
  const [messages, setMessages] = useState([]);
  const {
    addElement: addDocument,
    removeElement: removeDocument,
    allElements: allDocuments
  } = use_flat_category_store_default();
  const setEntryPoint = useCallback((id, entryPoint) => {
    setEntryPoints((prevPoints) => {
      return __spreadProps(__spreadValues({}, prevPoints), {
        [id]: entryPoint
      });
    });
  }, []);
  const removeEntryPoint = useCallback((id) => {
    setEntryPoints((prevPoints) => {
      const newPoints = __spreadValues({}, prevPoints);
      delete newPoints[id];
      return newPoints;
    });
  }, []);
  const getContextString = useCallback(
    (documents, categories) => {
      const documentsString = documents.map((document) => {
        return `${document.name} (${document.sourceApplication}):
${document.getContents()}`;
      }).join("\n\n");
      const nonDocumentStrings = printTree(categories);
      return `${documentsString}

${nonDocumentStrings}`;
    },
    [printTree]
  );
  const addContext = useCallback(
    (context, parentId, categories = defaultCopilotContextCategories) => {
      return addElement(context, categories, parentId);
    },
    [addElement]
  );
  const removeContext = useCallback(
    (id) => {
      removeElement(id);
    },
    [removeElement]
  );
  const getChatCompletionFunctionDescriptions = useCallback(
    (customEntryPoints) => {
      return entryPointsToChatCompletionFunctions(Object.values(customEntryPoints || entryPoints));
    },
    [entryPoints]
  );
  const getFunctionCallHandler = useCallback(
    (customEntryPoints) => {
      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || entryPoints));
    },
    [entryPoints]
  );
  const getDocumentsContext = useCallback(
    (categories) => {
      return allDocuments(categories);
    },
    [allDocuments]
  );
  const addDocumentContext = useCallback(
    (documentPointer, categories = defaultCopilotContextCategories) => {
      return addDocument(documentPointer, categories);
    },
    [addDocument]
  );
  const removeDocumentContext = useCallback(
    (documentId) => {
      removeDocument(documentId);
    },
    [removeDocument]
  );
  if (!props.publicApiKey) {
    if (props.cloudRestrictToTopic) {
      throw new Error(
        "To use the cloudRestrictToTopic feature, please sign up at https://copilotkit.ai and provide a publicApiKey."
      );
    }
  }
  let cloud = void 0;
  if (props.publicApiKey) {
    cloud = {
      guardrails: {
        input: {
          restrictToTopic: {
            enabled: props.cloudRestrictToTopic ? true : false,
            validTopics: ((_a2 = props.cloudRestrictToTopic) == null ? void 0 : _a2.validTopics) || [],
            invalidTopics: ((_b2 = props.cloudRestrictToTopic) == null ? void 0 : _b2.invalidTopics) || []
          }
        }
      }
    };
  }
  const copilotApiConfig = __spreadProps(__spreadValues({
    publicApiKey: props.publicApiKey
  }, cloud ? { cloud } : {}), {
    chatApiEndpoint,
    chatApiEndpointV2: `${props.url}/v2`,
    headers: props.headers || {},
    body: __spreadValues(__spreadValues({}, props.body), props.backendOnlyProps)
  });
  return /* @__PURE__ */ jsx(
    CopilotContext.Provider,
    {
      value: {
        entryPoints,
        chatComponentsCache,
        getChatCompletionFunctionDescriptions,
        getFunctionCallHandler,
        setEntryPoint,
        removeEntryPoint,
        getContextString,
        addContext,
        removeContext,
        getDocumentsContext,
        addDocumentContext,
        removeDocumentContext,
        copilotApiConfig,
        messages,
        setMessages
      },
      children
    }
  );
}
var defaultCopilotContextCategories = ["global"];
function entryPointsToChatCompletionFunctions(actions) {
  return actions.map(actionToChatCompletionFunction);
}
function entryPointsToFunctionCallHandler(actions) {
  return (chatMessages, functionCall) => __async(this, null, function* () {
    let actionsByFunctionName = {};
    for (let action2 of actions) {
      actionsByFunctionName[action2.name] = action2;
    }
    const action = actionsByFunctionName[functionCall.name || ""];
    if (action) {
      let functionCallArguments = [];
      if (functionCall.arguments) {
        functionCallArguments = JSON.parse(functionCall.arguments);
      }
      return yield action.handler(functionCallArguments);
    }
  });
}

export {
  CopilotKit,
  defaultCopilotContextCategories
};
//# sourceMappingURL=chunk-7LVVZQRG.mjs.map